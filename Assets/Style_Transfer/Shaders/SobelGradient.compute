#pragma kernel Sobel

// Textura de entrada (color o normales)
Texture2D<float4> InputTex;
// Textura de salida con bordes detectados
RWTexture2D<float4> Result;

SamplerState samplerLinear;

[numthreads(8, 8, 1)]
void Sobel(uint3 id : SV_DispatchThreadID)
{
    int2 size;
    InputTex.GetDimensions(size.x, size.y);

    if (id.x <= 0 || id.y <= 0 || id.x >= size.x - 1 || id.y >= size.y - 1)
    {
        Result[id.xy] = float4(0, 0, 0, 1); // Borde fuera
        return;
    }

    float3 tc00 = InputTex[int2(id.x - 1, id.y - 1)].rgb;
    float3 tc01 = InputTex[int2(id.x - 1, id.y    )].rgb;
    float3 tc02 = InputTex[int2(id.x - 1, id.y + 1)].rgb;

    float3 tc10 = InputTex[int2(id.x    , id.y - 1)].rgb;
    float3 tc12 = InputTex[int2(id.x    , id.y + 1)].rgb;

    float3 tc20 = InputTex[int2(id.x + 1, id.y - 1)].rgb;
    float3 tc21 = InputTex[int2(id.x + 1, id.y    )].rgb;
    float3 tc22 = InputTex[int2(id.x + 1, id.y + 1)].rgb;

    // Aplicamos Sobel horizontal y vertical
    float3 gx = -tc00 - 2.0 * tc01 - tc02 + tc20 + 2.0 * tc21 + tc22;
    float3 gy = -tc00 - 2.0 * tc10 - tc20 + tc02 + 2.0 * tc12 + tc22;

    float3 edge = sqrt(gx * gx + gy * gy); // Magnitud

    float strength = length(edge); // Grado de cambio
    strength = saturate(strength * 5.0); // Escalar (ajusta a gusto)

    Result[id.xy] = float4(strength.xxx, 1.0);
}
